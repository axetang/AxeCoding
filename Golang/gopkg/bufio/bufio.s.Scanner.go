/************************************************************************************
**Author:  Axe Tang; Email: axetang@163.com
**Package: bufio
**Element: bufio.Scanner
**Type: struct
------------------------------------------------------------------------------------
**Definition:
type Scanner struct {
   // contains filtered or unexported fields
	r            io.Reader // The reader provided by the client.
	split        SplitFunc // The function to split the tokens.
	maxTokenSize int       // Maximum size of a token; modified by tests.
	token        []byte    // Last token returned by split.
	buf          []byte    // Buffer used as argument to split.
	start        int       // First non-processed byte in buf.
	end          int       // End of data in buf.
	err          error     // Sticky error.
	empties      int       // Count of successive empty tokens.
	scanCalled   bool      // Scan has been called; buffer is in use.
	done         bool      // Scan has finished.
}
func NewScanner(r io.Reader) *Scanner
func (s *Scanner) Buffer(buf []byte, max int)
func (s *Scanner) Bytes() []byte
func (s *Scanner) Err() error
func (s *Scanner) Scan() bool
func (s *Scanner) Split(split SplitFunc)
func (s *Scanner) Text() string
------------------------------------------------------------------------------------
**Description:
Scanner provides a convenient interface for reading data such as a file of
newline-delimited lines of text. Successive calls to the Scan method will step
through the 'tokens' of a file, skipping the bytes between the tokens. The
specification of a token is defined by a split function of type SplitFunc; the
default split function breaks the input into lines with line termination stripped.
Split functions are defined in this package for scanning a file into lines, bytes,
UTF-8-encoded runes, and space-delimited words. The client may instead provide a
custom split function.
Scanning stops unrecoverably at EOF, the first I/O error, or a token too large to
fit in the buffer. When a scan stops, the reader may have advanced arbitrarily
far past the last token. Programs that need more control over error handling or
large tokens, or must run sequential scans on a reader, should use bufio.Reader
instead.
------------------------------------------------------------------------------------
**要点总结:
0. 对于简单的读取一行，在Reader类型中没有让人特别满意的方法。因此Go1.1增加了一个类型Scanner。
官方关于Go1.1增加该类型的说明如下：在bufio包中有多种方式获取文本输入，ReadBytes、ReadString
和独特的ReadLine，对于简单的目的这些都有些过于复杂了。在 Go1.1中，添加了一个新类型Scanner
以便更容易的处理如按行读取输入序列或空格分隔单词等这类简单的任务。它终结了如输入一个很长的有问题
的行这样的输入错误，并且提供了简单的默认行为：基于行的输入，每行都剔除分隔标识。这里的代码展示一次
输入一行：
scanner := bufio.NewScanner(os.Stdin)
for scanner.Scan() {
    fmt.Println(scanner.Text()) // Println will add back the final '\n'
}
if err := scanner.Err(); err != nil {
    fmt.Fprintln(os.Stderr, "reading standard input:", err)
}
输入的行为可以通过一个函数控制，来控制输入的每个部分（参阅SplitFunc的文档），但是对于复杂的问题
或持续传递错误的，可能还是需要原有接口。Scanner类型和Reader类型一样，没有任何导出的字段，同时它
也包装了一个io.Reader对象，但它没有实现io.Reader接口；
1. Scanner结构体提供了方便的读取数据的接口，如从换行符分隔的文本里读取每一行。成功调用的Scan
方法会逐步提供文件的token， 跳过token之间的字节。token由SplitFunc类型的分割函数指定； 默认的
分割函数会将输入分割为多个行，并去掉行尾的换行标志。 本包预定义的分割函数可以将文件分割为行、字节、
unicode码值、空白分隔的word。 调用者可以定制自己的分割函数。扫描会在抵达输入流结尾、遇到的第一
个I/O错误、token过大不能保存进缓冲时， 不可恢复的停止。当扫描停止后，当前读取位置可能会远在最后
一个获得的token后面。 需要更多对错误管理的控制或token很大，或必须从reader连续扫描的程序， 应
使用bufio.Reader代替。
1. Bytes方法返回最近一次Scan调用生成的token。底层数组指向的数据可能会被下一次Scan的调用重写。
2. Err返回Scanner遇到的第一个非EOF的错误。
3. Scan方法获取当前位置的token（该token可以通过Bytes或Text方法获得），并让Scanner的扫描位置
移动到下一个token。 当扫描因为抵达输入流结尾或者遇到错误而停止时， 本方法会返回false。在Scan
方法返回false后，Err方法将返回扫描时遇到的任何错误；除非是io.EOF，此时Err会返回nil。 若split
函数返回了100个空标记而没有推进输入，那么它就会派错（panic）。这是 scanner 的一个常见错误。
4. Split设置该Scanner的分割函数。本方法必须在Scan之前调用。
Bytes方法返回最近一次Scan调用生成的token， 会申请创建一个字符串保存token并返回该字符串;
5. Text returns the most recent token generated by a call to Scan as a newly
allocated string holding its bytes.
*************************************************************************************/
package main

import (
	"bufio"
	"fmt"
	"os"
	"strings"
)

func main() {
	fmt.Println("*********Text************")
	//TestText()
	fmt.Println("*********Bytes************")
	TestBytes()
}

func TestText() {
	const input = "This is The Golang Standard Library.\nWelcome you!\nBy Axe."
	scanner := bufio.NewScanner(strings.NewReader(input))
	scanner.Split(bufio.ScanBytes)
	count := 0
	for scanner.Scan() {
		count++
		fmt.Println(scanner.Text())
	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "reading input:", err)
	}
	fmt.Println(count)
}
func TestBytes() {
	const input = "This is The Golang Standard Library.\nWelcome you!\nBy Axe."
	scanner := bufio.NewScanner(strings.NewReader(input))
	scanner.Split(bufio.ScanWords)
	count := 0
	for scanner.Scan() {
		count++
		fmt.Println(string(scanner.Bytes()))

	}
	if err := scanner.Err(); err != nil {
		fmt.Fprintln(os.Stderr, "reading input:", err)
	}
	fmt.Println(count)
}
